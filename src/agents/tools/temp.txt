import json
import httpx
import base64
from email.mime.text import MIMEText
from langchain_core.tools import tool
from src.config.setup import *
from datetime import datetime, timedelta


async def get_access_token(session_id: str) -> str:
    if not session_id:
        return None

    session_json = await redis_client.get(f"session:{session_id}")
    if not session_json:
        return None

    session_data = json.loads(session_json)
    access_token = session_data.get("access_token")
    expires_at = session_data.get("expires_at")
    refresh_token = session_data.get("refresh_token")

    if expires_at and datetime.utcnow() >= datetime.fromisoformat(expires_at):
        if not refresh_token:
            return None

        try:
            async with httpx.AsyncClient() as client:
                resp = await client.post(
                    "https://oauth2.googleapis.com/token",
                    data={
                        "client_id": CLIENT_ID,
                        "client_secret": CLIENT_SECRET,
                        "refresh_token": refresh_token,
                        "grant_type": "refresh_token",
                    },
                    headers={"Content-Type": "application/x-www-form-urlencoded"},
                )
                resp.raise_for_status()
                token_data = resp.json()
                new_access_token = token_data["access_token"]
                expires_in = token_data["expires_in"]

                session_data["access_token"] = new_access_token
                session_data["expires_at"] = (
                    datetime.utcnow() + timedelta(seconds=expires_in)
                ).isoformat()

                await redis_client.set(
                    f"session:{session_id}",
                    json.dumps(session_data),
                    ex=expires_in,
                )

                return new_access_token
        except Exception as e:
            return None
    else:
        return access_token


# ==================== GMAIL TOOLS ====================


@tool
async def send_email(to: str, subject: str, body: str, session_id: str) -> str:
    """
    Send an email via the Gmail API with the provided content.

    Args:
        to (str): Recipient email address.
        subject (str): Email subject.
        body (str): Email body in plain text.
        session_id (str): saved in the chat history of the chat with you.

    Returns:
        str: A JSON string containing the Gmail API response or error.
    """
    try:
        access_token = await get_access_token(session_id)
        if not access_token:
            return json.dumps({"error": "No access token found"})

        message = MIMEText(body)
        message["to"] = to
        message["subject"] = subject

        raw_message = base64.urlsafe_b64encode(message.as_bytes()).decode()
        data = {"raw": raw_message}

        url = "https://gmail.googleapis.com/gmail/v1/users/me/messages/send"
        headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json",
        }

        async with httpx.AsyncClient() as client:
            resp = await client.post(url, headers=headers, json=data)
            resp.raise_for_status()
            return "sent successfully"

    except httpx.HTTPStatusError as e:
        error_message = e.response.json()
        return json.dumps(
            {
                "error": "Failed to send email",
                "status_code": e.response.status_code,
                "details": error_message,
            }
        )
    except Exception as e:
        return "An unexpected error occurred"


@tool
async def get_sent_emails_by_date(session_id: str, after: str, before: str) -> str:
    """
    Fetch the subject lines of sent emails from Gmail within a given date range.

    Args:
        session_id (str): saved in the chat history of the chat with you.
        after (str): Start date in the format yyyy/mm/dd.
        before (str): End date in the format yyyy/mm/dd.

    Returns:
        str: The subject of the email sent during the specified time period and the ID corresponding to that email.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found"

    query = f"in:sent after:{after} before:{before}"
    url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages?q={query}"
    headers = {"Authorization": f"Bearer {access_token}"}

    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=headers)
        resp.raise_for_status()
        messages = resp.json().get("messages", [])

        if not messages:
            return "No sent emails found in the given date range."

        results = []
        for msg in messages:
            msg_id = msg["id"]
            detail_url = (
                f"https://gmail.googleapis.com/gmail/v1/users/me/messages/{msg_id}"
            )
            detail_resp = await client.get(detail_url, headers=headers)
            detail_resp.raise_for_status()
            msg_data = detail_resp.json()

            headers_list = msg_data.get("payload", {}).get("headers", [])
            subject = next(
                (h["value"] for h in headers_list if h["name"] == "Subject"),
                "(No Subject)",
            )
            results.append(subject + f" ID: {msg_id}")

        return "\n".join(results)


@tool
async def get_received_emails_by_date(session_id: str, after: str, before: str) -> str:
    """
    Fetch the subject lines of received emails from Gmail within a given date range.

    Args:
        session_id (str): saved in the chat history of the chat with you
        after (str): Start date in format yyyy/mm/dd.
        before (str): End date in format yyyy/mm/dd.

    Returns:
        str: email subjects received during the specified time period and the ID corresponding to that email.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found"

    query = f"in:inbox after:{after} before:{before}"
    url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages?q={query}"
    headers = {"Authorization": f"Bearer {access_token}"}

    async with httpx.AsyncClient() as client:
        resp = await client.get(url, headers=headers)
        resp.raise_for_status()
        messages = resp.json().get("messages", [])

        if not messages:
            return "No emails found in the given date range."

        subjects = []
        for msg in messages:
            msg_id = msg["id"]
            detail_url = (
                f"https://gmail.googleapis.com/gmail/v1/users/me/messages/{msg_id}"
            )
            detail_resp = await client.get(detail_url, headers=headers)
            detail_resp.raise_for_status()
            msg_data = detail_resp.json()

            headers_list = msg_data.get("payload", {}).get("headers", [])
            subject = next(
                (h["value"] for h in headers_list if h["name"] == "Subject"),
                "(No Subject)",
            )
            subjects.append(subject + f" ID: {msg_id}")
        return "\n".join(subjects)


@tool  # error
async def delete_email_by_id(session_id: str, message_id: str) -> str:
    """
    Delete a specific email from the user's Gmail account using its message ID.

    Args:
        session_id (str): The session ID saved in the chat history.
        message_id (str): The ID of the Gmail message to delete.

    Returns:
        str: A confirmation message or error details.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    url = f"https://gmail.googleapis.com/gmail/v1/users/me/messages/{message_id}"
    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json",
    }

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.delete(url, headers=headers)
            resp.raise_for_status()
            return f"Message with ID {message_id} has been deleted successfully."
    except httpx.HTTPStatusError as e:
        return f"Failed to delete message: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


# ==================== GOOGLE DRIVE TOOLS ====================


@tool
async def create_file_in_folder_by_name(
    session_id: str,
    folder_name: str,
    file_name: str,
    content: str,
    mime_type: str = "text/plain",
) -> str:
    """
    Create a file in a specific folder by folder name (automatically finds folder ID).

    Args:
        session_id (str): The session ID saved in the chat history.
        folder_name (str): Name of the folder where the file will be created.
        file_name (str): Name of the file to create.
        content (str): Content of the file.
        mime_type (str): MIME type of the file (default: text/plain).

    Returns:
        str: File creation confirmation or error message.
    """
    folder_result = await find_folder_by_name(session_id, folder_name, exact_match=True)

    if "No folders found" in folder_result:
        return f"Folder '{folder_name}' not found. Please check the folder name or create it first."

    lines = folder_result.split("\n")
    folder_id = None
    for line in lines:
        if line.startswith("ID: "):
            folder_id = line.replace("ID: ", "").strip()
            break

    if not folder_id:
        return "Could not extract folder ID from search results."

    return await create_drive_file(session_id, file_name, content, mime_type, folder_id)


@tool
async def get_folder_id_by_name(
    session_id: str, folder_name: str, parent_folder_id: str = None
) -> str:
    """
    Simple helper to get just the folder ID by name (useful for other operations).

    Args:
        session_id (str): The session ID saved in the chat history.
        folder_name (str): Name of the folder to find.
        parent_folder_id (str, optional): ID of the parent folder to search in.

    Returns:
        str: Just the folder ID, or error message if not found.
    """
    folder_result = await find_folder_by_name(
        session_id, folder_name, parent_folder_id, exact_match=True
    )

    if "No folders found" in folder_result:
        return f"ERROR: Folder '{folder_name}' not found."

    lines = folder_result.split("\n")
    for line in lines:
        if line.startswith("ID: "):
            return line.replace("ID: ", "").strip()

    return "ERROR: Could not extract folder ID."


@tool
async def find_file_by_name(
    session_id: str, file_name: str, folder_id: str = None, exact_match: bool = True
) -> str:
    """
    Find file ID by name in Google Drive.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_name (str): Name of the file to search for.
        folder_id (str, optional): ID of the folder to search in. If None, searches in all accessible files.
        exact_match (bool): If True, searches for exact name match. If False, searches for files containing the name.

    Returns:
        str: File information including ID, or error message if not found.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    url = "https://www.googleapis.com/drive/v3/files"
    headers = {"Authorization": f"Bearer {access_token}"}

    # Build query
    if exact_match:
        name_query = f"name = '{file_name}'"
    else:
        name_query = f"name contains '{file_name}'"

    query_parts = [name_query]
    if folder_id:
        query_parts.append(f"'{folder_id}' in parents")

    params = {
        "q": " and ".join(query_parts),
        "fields": "files(id,name,mimeType,parents,webViewLink)",
        "pageSize": 50,
    }

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(url, headers=headers, params=params)
            resp.raise_for_status()
            data = resp.json()

            files = data.get("files", [])
            if not files:
                return f"No files found with name '{file_name}'."

            results = []
            for file in files:
                file_info = (
                    f"Name: {file['name']}\n"
                    f"ID: {file['id']}\n"
                    f"Type: {file['mimeType']}\n"
                    f"Parents: {', '.join(file.get('parents', []))}\n"
                    f"Link: {file.get('webViewLink', 'N/A')}\n"
                    f"---"
                )
                results.append(file_info)

            return f"Found {len(files)} file(s):\n\n" + "\n".join(results)

    except httpx.HTTPStatusError as e:
        return f"Failed to search files: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def find_folder_by_name(
    session_id: str,
    folder_name: str,
    parent_folder_id: str = None,
    exact_match: bool = True,
) -> str:
    """
    Find folder ID by name in Google Drive (can be used to retrieve the ID of a folder when you want to create a file in a specific folder).

    Args:
        session_id (str): The session ID saved in the chat history.
        folder_name (str): Name of the folder to search for.
        parent_folder_id (str, optional): ID of the parent folder to search in.
        exact_match (bool): If True, searches for exact name match. If False, searches for folders containing the name.

    Returns:
        str: Folder information including ID, or error message if not found.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    url = "https://www.googleapis.com/drive/v3/files"
    headers = {"Authorization": f"Bearer {access_token}"}

    if exact_match:
        name_query = f"name = '{folder_name}'"
    else:
        name_query = f"name contains '{folder_name}'"

    query_parts = [name_query, "mimeType = 'application/vnd.google-apps.folder'"]

    if parent_folder_id:
        query_parts.append(f"'{parent_folder_id}' in parents")

    params = {
        "q": " and ".join(query_parts),
        "fields": "files(id,name,parents,webViewLink)",
        "pageSize": 50,
    }

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(url, headers=headers, params=params)
            resp.raise_for_status()
            data = resp.json()

            folders = data.get("files", [])
            if not folders:
                return f"No folders found with name '{folder_name}'."

            results = []
            for folder in folders:
                folder_info = (
                    f"Name: {folder['name']}\n"
                    f"ID: {folder['id']}\n"
                    f"Parents: {', '.join(folder.get('parents', []))}\n"
                    f"Link: {folder.get('webViewLink', 'N/A')}\n"
                    f"---"
                )
                results.append(folder_info)

            return f"Found {len(folders)} folder(s):\n\n" + "\n".join(results)

    except httpx.HTTPStatusError as e:
        return f"Failed to search folders: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def find_file_by_path(session_id: str, file_path: str) -> str:
    """
    Find file ID by its path in Google Drive (e.g., "Documents/Projects/myfile.txt").

    Args:
        session_id (str): The session ID saved in the chat history.
        file_path (str): Path to the file (folder1/folder2/filename.ext).

    Returns:
        str: File information including ID, or error message if not found.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        path_parts = file_path.strip("/").split("/")
        current_folder_id = "root"

        for i, part in enumerate(path_parts[:-1]):
            folder_result = await find_folder_by_name(
                session_id, part, current_folder_id, exact_match=True
            )

            if "No folders found" in folder_result:
                return (
                    f"Folder '{part}' not found in path '{'/'.join(path_parts[:i+1])}'."
                )

            lines = folder_result.split("\n")
            for line in lines:
                if line.startswith("ID: "):
                    current_folder_id = line.replace("ID: ", "").strip()
                    break
            else:
                return f"Could not extract folder ID for '{part}'."

        filename = path_parts[-1]
        file_result = await find_file_by_name(
            session_id, filename, current_folder_id, exact_match=True
        )

        return file_result

    except Exception as e:
        return f"An unexpected error occurred while searching path: {str(e)}"


@tool
async def get_file_path(session_id: str, file_id: str) -> str:
    """
    Get the full path of a file in Google Drive by traversing parent folders.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_id (str): ID of the file to get path for.

    Returns:
        str: Full path of the file or error message.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        async with httpx.AsyncClient() as client:
            path_parts = []
            current_id = file_id

            while current_id and current_id != "root":
                resp = await client.get(
                    f"https://www.googleapis.com/drive/v3/files/{current_id}?fields=name,parents",
                    headers={"Authorization": f"Bearer {access_token}"},
                )
                resp.raise_for_status()
                data = resp.json()

                path_parts.insert(0, data["name"])
                parents = data.get("parents", [])
                current_id = parents[0] if parents else None

            if not path_parts:
                return "Could not determine file path."

            return "/" + "/".join(path_parts)

    except httpx.HTTPStatusError as e:
        return f"Failed to get file path: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def search_files_advanced(
    session_id: str,
    query: str = None,
    file_type: str = None,
    modified_after: str = None,
    modified_before: str = None,
    owner_email: str = None,
    shared_with_me: bool = False,
) -> str:
    """
    Advanced search for files in Google Drive with multiple filters.

    Args:
        session_id (str): The session ID saved in the chat history.
        query (str, optional): Text to search in file names and content.
        file_type (str, optional): MIME type or extension (e.g., 'pdf', 'image/jpeg').
        modified_after (str, optional): Find files modified after this date (YYYY-MM-DD).
        modified_before (str, optional): Find files modified before this date (YYYY-MM-DD).
        owner_email (str, optional): Email of the file owner.
        shared_with_me (bool): If True, search only in "Shared with me".

    Returns:
        str: Search results with file information.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    url = "https://www.googleapis.com/drive/v3/files"
    headers = {"Authorization": f"Bearer {access_token}"}

    query_parts = []

    if query:
        query_parts.append(f"fullText contains '{query}' or name contains '{query}'")

    if file_type:
        if "/" not in file_type:  # If it's just an extension
            query_parts.append(f"name contains '.{file_type}'")
        else:  # If it's a full MIME type
            query_parts.append(f"mimeType = '{file_type}'")

    if modified_after:
        query_parts.append(f"modifiedTime > '{modified_after}T00:00:00'")

    if modified_before:
        query_parts.append(f"modifiedTime < '{modified_before}T23:59:59'")

    if owner_email:
        query_parts.append(f"'{owner_email}' in owners")

    if shared_with_me:
        query_parts.append("sharedWithMe = true")

    params = {
        "fields": "files(id,name,mimeType,modifiedTime,size,owners,webViewLink,shared)",
        "pageSize": 50,
    }

    if query_parts:
        params["q"] = " and ".join(query_parts)

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(url, headers=headers, params=params)
            resp.raise_for_status()
            data = resp.json()

            files = data.get("files", [])
            if not files:
                return "No files found matching the search criteria."

            results = []
            for file in files:
                owners = file.get("owners", [])
                owner_names = [
                    owner.get("displayName", owner.get("emailAddress", "Unknown"))
                    for owner in owners
                ]

                file_info = (
                    f"Name: {file['name']}\n"
                    f"ID: {file['id']}\n"
                    f"Type: {file['mimeType']}\n"
                    f"Modified: {file.get('modifiedTime', 'Unknown')}\n"
                    f"Size: {file.get('size', 'Unknown')} bytes\n"
                    f"Owners: {', '.join(owner_names)}\n"
                    f"Shared: {'Yes' if file.get('shared', False) else 'No'}\n"
                    f"Link: {file.get('webViewLink', 'N/A')}\n"
                    f"---"
                )
                results.append(file_info)

            return f"Found {len(files)} file(s):\n\n" + "\n".join(results)

    except httpx.HTTPStatusError as e:
        return f"Failed to search files: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def list_drive_files(
    session_id: str, folder_id: str = None, query: str = None
) -> str:
    """
    List files in Google Drive with optional filtering.

    Args:
        session_id (str): The session ID saved in the chat history.
        folder_id (str, optional): ID of the folder to list files from. If None, lists from root.
        query (str, optional): Search query to filter files (e.g., "name contains 'document'").

    Returns:
        str: List of files with their names, IDs, and metadata.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    url = "https://www.googleapis.com/drive/v3/files"
    headers = {"Authorization": f"Bearer {access_token}"}

    params = {
        "fields": "files(id,name,mimeType,modifiedTime,size,webViewLink)",
        "pageSize": 100,
    }

    # Build query string
    query_parts = []
    if folder_id:
        query_parts.append(f"'{folder_id}' in parents")
    if query:
        query_parts.append(query)

    if query_parts:
        params["q"] = " and ".join(query_parts)

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(url, headers=headers, params=params)
            resp.raise_for_status()
            data = resp.json()

            files = data.get("files", [])
            if not files:
                return "No files found."

            results = []
            for file in files:
                file_info = (
                    f"Name: {file['name']}\n"
                    f"ID: {file['id']}\n"
                    f"Type: {file['mimeType']}\n"
                    f"Modified: {file.get('modifiedTime', 'Unknown')}\n"
                    f"Size: {file.get('size', 'Unknown')} bytes\n"
                    f"Link: {file.get('webViewLink', 'N/A')}\n"
                    f"---"
                )
                results.append(file_info)

            return "\n".join(results)

    except httpx.HTTPStatusError as e:
        return f"Failed to list files: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def create_drive_file(
    session_id: str,
    name: str,
    content: str,
    mime_type: str = "text/plain",
    parent_folder_id: str = None,
) -> str:
    """
    Create a new file in Google Drive.

    Args:
        session_id (str): The session ID saved in the chat history.
        name (str): Name of the file to create.
        content (str): Content of the file.
        mime_type (str): MIME type of the file (default: text/plain).
        parent_folder_id (str, optional): ID of the parent folder.

    Returns:
        str: File creation confirmation with file ID and link.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    # Metadata for the file
    metadata = {"name": name, "mimeType": mime_type}

    if parent_folder_id:
        metadata["parents"] = [parent_folder_id]

    try:
        async with httpx.AsyncClient() as client:
            # First, create the file metadata
            files = {
                "metadata": (None, json.dumps(metadata), "application/json"),
                "media": (name, content.encode(), mime_type),
            }

            resp = await client.post(
                "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,name,webViewLink",
                headers={"Authorization": f"Bearer {access_token}"},
                files=files,
            )
            resp.raise_for_status()

            file_data = resp.json()
            return (
                f"File created successfully!\n"
                f"Name: {file_data['name']}\n"
                f"ID: {file_data['id']}\n"
                f"Link: {file_data.get('webViewLink', 'N/A')}"
            )

    except httpx.HTTPStatusError as e:
        return f"Failed to create file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def read_drive_file(session_id: str, file_id: str) -> str:
    """
    Read content from a Google Drive file.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_id (str): ID of the file to read.

    Returns:
        str: Content of the file or error message.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        async with httpx.AsyncClient() as client:
            # Get file metadata first
            metadata_resp = await client.get(
                f"https://www.googleapis.com/drive/v3/files/{file_id}?fields=name,mimeType,size",
                headers={"Authorization": f"Bearer {access_token}"},
            )
            metadata_resp.raise_for_status()
            metadata = metadata_resp.json()

            # Download file content
            content_resp = await client.get(
                f"https://www.googleapis.com/drive/v3/files/{file_id}?alt=media",
                headers={"Authorization": f"Bearer {access_token}"},
            )
            content_resp.raise_for_status()

            return (
                f"File: {metadata['name']}\n"
                f"Type: {metadata['mimeType']}\n"
                f"Size: {metadata.get('size', 'Unknown')} bytes\n"
                f"Content:\n{'-'*50}\n"
                f"{content_resp.text}"
            )

    except httpx.HTTPStatusError as e:
        return f"Failed to read file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def update_drive_file(session_id: str, file_id: str, content: str) -> str:
    """
    Update content of an existing Google Drive file.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_id (str): ID of the file to update.
        content (str): New content for the file.

    Returns:
        str: Update confirmation or error message.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.patch(
                f"https://www.googleapis.com/upload/drive/v3/files/{file_id}?uploadType=media",
                headers={
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "text/plain",
                },
                content=content.encode(),
            )
            resp.raise_for_status()

            return f"File with ID {file_id} has been updated successfully."

    except httpx.HTTPStatusError as e:
        return f"Failed to update file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def delete_drive_file(session_id: str, files_id: str) -> str:
    """
    Delete one or more files from Google Drive.

    Args:
        session_id (str): The session ID used to retrieve the access token.
        files_id (str): A single file ID or a space-separated string of multiple file IDs.

    Returns:
        str: Confirmation message if successful, or a detailed error message if failed.
    """

    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.delete(
                f"https://www.googleapis.com/drive/v3/files/{files_id}",
                headers={"Authorization": f"Bearer {access_token}"},
            )
            resp.raise_for_status()

            return f"File with ID {files_id} has been deleted successfully."

    except httpx.HTTPStatusError as e:
        return f"Failed to delete file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def create_drive_folder(
    session_id: str, name: str, parent_folder_id: str = None
) -> str:
    """
    Create a new folder in Google Drive.

    Args:
        session_id (str): The session ID saved in the chat history.
        name (str): Name of the folder to create.
        parent_folder_id (str, optional): ID of the parent folder.

    Returns:
        str: Folder creation confirmation with folder ID.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    metadata = {"name": name, "mimeType": "application/vnd.google-apps.folder"}

    if parent_folder_id:
        metadata["parents"] = [parent_folder_id]

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.post(
                "https://www.googleapis.com/drive/v3/files?fields=id,name,webViewLink",
                headers={
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "application/json",
                },
                json=metadata,
            )
            resp.raise_for_status()

            folder_data = resp.json()
            return (
                f"Folder created successfully!\n"
                f"Name: {folder_data['name']}\n"
                f"ID: {folder_data['id']}\n"
                f"Link: {folder_data.get('webViewLink', 'N/A')}"
            )

    except httpx.HTTPStatusError as e:
        return f"Failed to create folder: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def move_drive_file(
    session_id: str, file_id: str, new_parent_id: str, old_parent_id: str = None
) -> str:
    """
    Move a file to a different folder in Google Drive.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_id (str): ID of the file to move.
        new_parent_id (str): ID of the new parent folder.
        old_parent_id (str, optional): ID of the old parent folder (if known).

    Returns:
        str: Move confirmation or error message.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    try:
        async with httpx.AsyncClient() as client:
            # If old parent not specified, get current parents
            if not old_parent_id:
                resp = await client.get(
                    f"https://www.googleapis.com/drive/v3/files/{file_id}?fields=parents",
                    headers={"Authorization": f"Bearer {access_token}"},
                )
                resp.raise_for_status()
                parents = resp.json().get("parents", [])
                old_parent_id = ",".join(parents) if parents else ""

            # Move the file
            params = {"addParents": new_parent_id, "removeParents": old_parent_id}

            resp = await client.patch(
                f"https://www.googleapis.com/drive/v3/files/{file_id}",
                headers={"Authorization": f"Bearer {access_token}"},
                params=params,
            )
            resp.raise_for_status()

            return f"File with ID {file_id} has been moved successfully."

    except httpx.HTTPStatusError as e:
        return f"Failed to move file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"


@tool
async def share_drive_file(
    session_id: str, file_id: str, email: str, role: str = "reader"
) -> str:
    """
    Share a Google Drive file with someone.

    Args:
        session_id (str): The session ID saved in the chat history.
        file_id (str): ID of the file to share.
        email (str): Email address of the person to share with.
        role (str): Permission role - "reader", "writer", "commenter", or "owner".

    Returns:
        str: Share confirmation or error message.
    """
    access_token = await get_access_token(session_id)
    if not access_token:
        return "No access token found."

    permission_data = {"type": "user", "role": role, "emailAddress": email}

    try:
        async with httpx.AsyncClient() as client:
            resp = await client.post(
                f"https://www.googleapis.com/drive/v3/files/{file_id}/permissions",
                headers={
                    "Authorization": f"Bearer {access_token}",
                    "Content-Type": "application/json",
                },
                json=permission_data,
            )
            resp.raise_for_status()

            return f"File with ID {file_id} has been shared with {email} as {role}."

    except httpx.HTTPStatusError as e:
        return f"Failed to share file: {e.response.text}"
    except Exception as e:
        return f"An unexpected error occurred: {str(e)}"
